---
title: Gestão de dados de referência
author: Francisco
date: 2023-03-27
execute:
  echo: true
format:
  revealjs:
    fontsize: 20
---

```{r}
#| echo: false
#| warning: false
library(DBI); library(dplyr); library(kableExtra); library(lubridate); library(data.table)
conn <- dbConnect(RSQLite::SQLite(), "db.sqlite")

extrato <- function() {
  execucao |>
  full_join(classificador, by = "code") |>
  filter(valid_from <= dt_doc, valid_to > dt_doc) |>
  select(doc, dt_doc, code, description, vl_doc) |> 
  mutate(year = year(dt_doc)) |> 
  group_by(year, code, description) |> 
  summarize(vl_emp = sum(vl_doc)) |>
  kable()
}
```

```{bash}
#| echo: false
sqlite3 db.sqlite < sql/01_create.sql 
sqlite3 db.sqlite < sql/02_insert.sql
```

```{r}
#| echo: false
classificador <- tbl(conn, "classificador")
execucao <- tbl(conn, "execucao")
```

# Introdução

> The best layouts/formats (as well as software and interfaces) for data entry and data analysis might be different. It is important to take this into account, and ideally automate the conversion from one to another.
> 
> -- [Data Organization in Spreadsheets for Social Scientists: Formatting Data Tables in Spreadsheets](https://datacarpentry.org/spreadsheets-socialsci/01-format-data.html#callout1)

Nessa etapa o objetivo é sugerir um modelo de dados para armazenamento que facilite sua utilização nos fluxos de dados automatizados.

O modelo vai ser baseado em três conceitos:

- [Tabela bitemporal](https://en.wikipedia.org/wiki/Bitemporal_modeling) para gestão de [dados de referência](https://en.wikipedia.org/wiki/Reference_data)
- [Trilha de auditoria](https://dba.stackexchange.com/questions/15186/what-is-an-audit-table) das alterações
- [Listas de referência cruzada](https://en.wikipedia.org/wiki/Schema_crosswalk) entre as [classificações históricas](https://www.youtube.com/watch?v=ummPGYFr_eE)

Para validação[^20230512T132602] do modelo o ideal é fazermos comparações entre a usabilidade das alternativas para atender as necessidades de informação (de todos os atores). 

[^20230512T132602]: Veja que ainda podemos decidir que não faz sentido a utilização do modelo por dificuldades na entrada dos dados.

# Operações

## Criação (insert)

:::: {.columns}
::: {.column width="40%"}
O classificador inicial foi populado com as fontes de recurso 10, 20 e 60.

As colunas `id`, `created_at` e `updated_at` devem idealmente ser geradas de forma automática para tornar o preenchimento mais ágil e menos sujeito a erros. Elas não serão mostradas a menos que necessário.
:::
::: {.column width="60%"}
```{r}
#| echo: false
kable(classificador)
```
:::
::::

## Transposição parcial (insert)

```{bash}
#| echo: false
sqlite3 db.sqlite < sql/03_insert.sql 
```

:::: {.columns}
::: {.column width="40%"}
Em junho/2021 foi criado a fonte de recurso _61 - Recursos Diretamente Arrecadados Vinculados_.

O objetivo é permitir a identificação de recursos diretamente arrecadados que possuem vinculação específica para evitar que o saldo financeiro dessas fontes fosse incorretamente revertido para o caixa único no encerramento do exercício. 

Até então esses recursos eram classificados na fonte 60.
:::
::: {.column width="60%"}
```{r}
#| echo: false
classificador |>
  select(code, description, valid_from, valid_to) |> 
  kable() |> 
  row_spec(4, background = "#d3d3d3")
```
:::
::::

## Correção (update)

```{bash}
#| echo: false
sqlite3 db.sqlite < sql/04_update.sql 
```

:::: {.columns}

::: {.column width="40%"}
Na inicialização do classificador foi identificado que a descrição da fonte 10 foi incorretamente digitada sem acento.

Ps. Na modelagem atual o histórico dessa alteração é perdido.
:::

::: {.column width="60%"}
```{r}
#| echo: false
classificador |>
  select(code, description, valid_from, valid_to) |> 
  kable() |> 
  row_spec(1, background = "#d3d3d3")
```
:::
::::

## Bloqueio e transposição total (update)

```{bash}
#| echo: false
sqlite3 db.sqlite < sql/05_update.sql 
```

:::: {.columns}

::: {.column width="40%"}
A partir de jan/2022 foi decidido que as fontes devem identificar apenas se trata-se de recurso com destinação específica ou não, sendo o responsável pela arrecadação controlado a partir da unidade orçamentária.
:::

::: {.column width="60%"}
```{r}
#| echo: false
classificador |>
  select(code, description, valid_from, valid_to) |> 
  kable() |> 
  row_spec(3:4, background = "#d3d3d3")
```
:::
::::

## Descrição (update)

```{bash}
#| echo: false
sqlite3 db.sqlite < sql/06_update.sql 
```

:::: {.columns}

::: {.column width="40%"}
A partir de jan/2023 a fonte 10 deve ser chamada de "recursos não vinculados".
:::

::: {.column width="60%"}
```{r}
#| echo: false
classificador |>
  select(code, description, valid_from, valid_to) |> 
  kable() |> 
  row_spec(c(1, 5), background = "#d3d3d3")
```
:::
::::

# Necessidades de informação

## Cruzamento para recuperação das informações cadastrais {.smaller}

:::: {.columns}

::: {.column width="50%"}
```{r}
#| echo: false
classificador |>
  select(code, description, valid_from, valid_to) |> 
  kable() 
```
:::

::: {.column width="50%"}
```{r}
#| echo: false  
  execucao |>
  kable()
```
:::
::::




```{r}
  execucao |>
  full_join(classificador, by = "code") |>
  filter(valid_from <= dt_doc, valid_to > dt_doc) |> 
  select(doc, code, description, dt_doc, vl_doc, hist) |> 
  kable()
```

## Classificações vigentes atualmente

Essa consulta representa a [tabela de classificação publicada atualmente](https://docs.google.com/spreadsheets/d/1et_q4xTH2p6umWduHRZP-lFDXXK0Q6kN/edit#gid=1636393178) pela DCPPN

```{r}
classificador |> 
  select(code, description, valid_from, valid_to) |> 
  filter(valid_to == "9999-12-31") |> 
  arrange(code) |> 
  kable()
```

## Classificações vigentes em uma data específica

```{r}
classificador |> 
  select(code, description, valid_from, valid_to) |> 
  filter("2022-01-01" >= valid_from & "2022-01-01" < valid_to) |> 
  arrange(code) |> 
  kable()
```

Vale ressaltar que como a vigência é especificada como um intervalo semi-fechado $[a, b)$, o seguinte filtro gera resultados incorretos

```{r}
classificador |> 
  select(code, description, valid_from, valid_to) |> 
  filter("2022-01-01" >= valid_from & "2022-01-01" <= valid_to) |> 
  arrange(code) |> 
  kable()
```

## Classificações vigentes na inicialização do classificador {visibility="hidden"}

```{r}
classificador |> 
  select(code, description, valid_from, valid_to) |> 
  filter(valid_from == "0001-01-01") |> 
  arrange(code) |> 
  kable()
```

## Histórico de alterações de uma classificação {visibility="hidden"}

```{r}
classificador |> 
  filter(code == 10) |> 
  arrange(desc(valid_to)) |> 
  kable()
```

## Número de alterações sofridas por determinada classificação {visibility="hidden"}

```{r}
classificador |>
  count(code) |> kable()
```

## Tópicos para discussão {visibility="hidden"}

- Imagine que em 04/05/2023 a DCAF fez o cruzamento de dados da seção anterior. No dia seguinte a DCPPN fez uma alteração no classificador da despesa alterando a descrição da fonte 503 "Recursos Diretamente Arrecadados" para "RDA". Sem ter que realizar novamente o cruzamento de todas as linhas, como a DCAF pode identificar essa modificação realizada pela DCPPN?

- Como garantir ou validar que a data de fim de vigência de uma classificação seja igual a data de inicio de vigência de outra classificação?

- Classificação deve ser utilizada na LOA mas não será utilizada durante a execução

- Necessidades de informação: changelog classificador da despesa com diff

- Quem alterou a descrição da fonte 503 "Recursos Diretamente Arrecadados" para "RDA"? Porque essa alteração foi realizada?

- Em uma data específica eu fiz a classificação de um empenho na fonte 501. Hoje, quais são as classificações possíveis para esse empenho?

- Qual o mapeamento entre as classificações do SIAFI e GRP?

- De qual coluna eu faço a extração da interpretação do elemento item 1301 e 1305?

- Armazenamento com git

    ```
      classificador/
    ├── elemento
    └── fonte
        └── 10
            ├── latest.md
            ├── v1.md
            ├── v2.md
            └── v3.md
    ```

## Operadores lógicos

- `cri` - criado sem reaproveitamento
- `cri-r` - criado com reaproveitamento (reativação de código)
- `doc` - documentação [alterada] (obs.: inclui todos os demais grupos de informação, ex.: interpretação, notas etc)
- `dsc` - descrição [alterada]
- `dsc-doc` - descrição e documentação [alterados]
- `dsc-n` - descrição e nível [alterados]
- `nv` - nível [alterado]
- `blq`	- bloqueado
- `dsbq` - desbloqueado
- `tpd` - transposição parcial de
- `tpp` - transposição parcial para
- `ttd` - transposição total de
- `ttp` - transposição total para [cod. fica bloqueado]


```{r}
dbDisconnect(conn)
```